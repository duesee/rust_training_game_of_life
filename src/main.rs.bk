extern crate rand;

use rand::distributions::{IndependentSample, Range};
use rand::Rng;
use std::thread::sleep;
use std::time::Duration;

enum BufferLocation { Foreground, Background }

struct Gol {
    rows: usize,
    cols: usize,
    // We use two buffers: During the calculation, the foreground buffer
    // will only be read from and the background buffer can be modified.
    // After the calculation finished, the buffers will be swapped, so
    // that the fg-buffer becomes the bg-buffer and vice versa.
    switch: bool,
    buffer_a: Vec<Vec<bool>>,
    buffer_b: Vec<Vec<bool>>,
}

impl Gol {
    fn new(rows: usize, cols: usize) -> Gol {
        // We allocate two more rows and cols to construct an always
        // dead phantom border. This simplifies the next-generation algorithm.
        let buffer_a = vec![vec![false; cols + 2]; rows + 2];
        let buffer_b = vec![vec![false; cols + 2]; rows + 2];

        Gol {
            rows: rows,
            cols: cols,
            switch: true,
            buffer_a: buffer_a,
            buffer_b: buffer_b,
        }
    }

    fn populate(&mut self) {
        let     rows    = self.rows;
        let     cols    = self.cols;
        let mut buffer  = self.get_buffer(BufferLocation::Foreground);
        let mut rng     = rand::thread_rng();
        let     between = Range::new(0, 100);

        for row in &mut buffer[1..rows + 1] {
            for col in &mut row[1..cols + 1] {
                *col = between.ind_sample(&mut rng) < 7;
            }
        }
    }

    fn print(&mut self) {
        let rows   = self.rows;
        let cols   = self.cols;
        let buffer = self.get_buffer(BufferLocation::Foreground);

        for row in &buffer[1..rows + 1] {
            for col in &row[1..cols + 1] {
                if *col { print!("â€¢") } else { print!(" ") };
            }
            println!("");
        }
    }

    fn next(&mut self) {
        {
            let     rows      = self.rows;
            let     cols      = self.cols;
            let     buffer_fg = self.get_buffer(BufferLocation::Foreground).clone();
            let mut buffer_bg = self.get_buffer(BufferLocation::Background);

            for row_cnt in 1..rows + 1 {
                for col_cnt in 1..cols + 1 {
                    let mut counter = -1;
                    for row_d in 0..3 {
                        for col_d in 0..3 {
                            if buffer_fg[row_cnt + row_d - 1]
                                        [col_cnt + col_d - 1] {
                                counter += 1;
                            }
                        }
                    }
                    buffer_bg[row_cnt][col_cnt] = counter == 2 || counter == 3;
                }
            }
        }

        // Swap fg and bg buffers
        self.switch = !self.switch;
    }

    fn get_buffer(&mut self, loc: BufferLocation) -> &mut Vec<Vec<bool>> {
        let &mut buffer = match loc {
            BufferLocation::Foreground => {
                match self.switch {
                    true  => &mut self.buffer_a,
                    false => &mut self.buffer_b,
                }
            },
            BufferLocation::Background => {
                match self.switch {
                    true  => &mut self.buffer_b,
                    false => &mut self.buffer_a,
                }
            }
        };

        buffer
    }
}

fn main() {
    let mut gol = Gol::new(40, 60);

    gol.populate();

    for cnt in 1.. {
        gol.print();
        gol.next();
        println!("{:^60}", format!("<<< Generation: {:>6} >>>", cnt));
        sleep(Duration::from_millis(100));
    }
}
